/**
 * One-Time-Pad Filesystem (OTPFS, or otpfs)
 *
 * Bill Brassfield ( https://github.com/brassb )
 *
 * This project:  https://github.com/brassb/otpfs
 *
 * June 2021
 *
 * This filesystem encrypts files using a "one-time-pad" generated by
 * a series of serial-numbered sha256sum hashes of a passphrase.
 *
 * Usage:
 *
 *   ./otpfs -f --user_data source_dir=/path/to/raw/storage /path/to/otpfs_mount_point
 *
 *   ./otpfs -f --user_data serial_type=int,serial_start=9876,serial_step=7,source_dir=/path/to/raw/storage /path/to/otpfs_mount_point
 *
 *   ./otpfs -f --user_data serial_type=long,serial_start=12345,serial_step=6789,source_dir=/path/to/raw/storage /path/to/otpfs_mount_point
 *
 * License: GNU GPL
 *
 * Warranty: NONE - Use at your own risk and/or peril!
 *
 * This is NOT to be used as part of critical infrastructure for
 * Production environments.  This code is for teaching, learning,
 * and experimental lab-use only, for the purposes of gaining
 * further knowledge/insight into Linux FUSE (Filesystems in USEr
 * space, rather than in kernel space).  It also may be used to
 * demonstrate the use of pseudo-randomly-generated One-Time-Pad
 * cryptographic ciphers, and why IT IS A VERY BAD IDEA to reuse
 * a One-Time-Pad (any part of it) to encrypt different pieces of
 * plaintext data.  You have been warned!
 *
 */

#define FUSE_USE_VERSION 30

#include <fuse.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <sys/statvfs.h>
#include <errno.h>
#include <sys/stat.h>
#include <openssl/sha.h>
#include <sys/statfs.h>
#include <dirent.h>

#define SERIAL_TYPE_INT           0      // passphrase serial numbers are of type int
#define SERIAL_TYPE_LONG          1      // passphrase serial numbers are of type long

#define DEFAULT_SHOW_PASSPHRASE   "no"   // can be "no"  or "yes"
#define DEFAULT_SERIAL_TYPE       "int"  // can be "int" or "long"
#define DEFAULT_SERIAL_START      "0"
#define DEFAULT_SERIAL_STEP       "1"
#define DEFAULT_SOURCE_DIR        "/path/to/where/the/raw/data/is/stored"

#define MAX_PASSPHRASE_LENGTH     1023
#define USERDATA_KV_MAX_LENGTH    1023

#define MAX_UNSIGNED_INT_DIGITS   10     // 2^32 - 1 = 4294967295            has 10 digits
#define MAX_UNSIGNED_LONG_DIGITS  20     // 2^64 - 1 = 18446744073709551615  has 20 digits

char passPhrase[MAX_PASSPHRASE_LENGTH + 1];

struct otpfs_user_data {
  char* show_passphrase;
  char* serial_type;
  char* serial_start;
  char* serial_step;
  char* source_dir;
};

unsigned char serialType = SERIAL_TYPE_INT;

int serialStartInt = 0;
int serialStepInt  = 1;

long serialStartLong = 0L;
long serialStepLong  = 1L;

struct otpfs_user_data* globalOtpfsUserData = NULL;

struct hash_bytes_struct {
  int length;
  unsigned char* hash_bytes;
};


void calc_sha256_hash_bytes(char *string, char hashAsBytes[SHA256_DIGEST_LENGTH]) {
  SHA256_CTX sha256ctx;
  SHA256_Init(&sha256ctx);
  SHA256_Update(&sha256ctx, string, strlen(string));
  SHA256_Final(hashAsBytes, &sha256ctx);
}


struct hash_bytes_struct* calcHashBytesInt(int serialStart, int hashCount) {
  struct hash_bytes_struct* hashBytesStructPtr = (struct hash_bytes_struct*) malloc(sizeof(struct hash_bytes_struct));
  int  retVal;
  char serialNumStr[MAX_UNSIGNED_INT_DIGITS + 2];                                  // 10 digits + '\n' + '\0' = 12
  char serialPassPh[MAX_PASSPHRASE_LENGTH + 1 + MAX_UNSIGNED_INT_DIGITS + 1 + 1];  // 1023 + 1 + 10 + 1 + 1 = 1036 (the ones are for '\n', '\n', '\0')
  int hashBytesLength = hashCount * SHA256_DIGEST_LENGTH;
  unsigned char hashAsByteArray[SHA256_DIGEST_LENGTH];

  // printf("calcHashBytes: serialStart = %d\n", serialStart);
  // printf("calcHashBytes: hashCount   = %d\n", hashCount);
  // printf("\n");

  hashBytesStructPtr->length     = hashCount;
  hashBytesStructPtr->hash_bytes = (unsigned char*) malloc(hashCount * SHA256_DIGEST_LENGTH * sizeof(unsigned char));

  for (int i=0; i<hashCount*SHA256_DIGEST_LENGTH; i++) {
    hashBytesStructPtr->hash_bytes[i] = 0;
  }

  for (int i=0; i<hashCount; i++) {
    // sprintf(serialNumStr, "%10d\n", i + serialStart);
    sprintf(serialNumStr, "%10d\n", (i + serialStart)*serialStepInt + serialStartInt);
    sprintf(serialPassPh, "%s%s", passPhrase, serialNumStr);
    calc_sha256_hash_bytes(serialPassPh, hashAsByteArray);

    // printf("calcHashBytes: serialPassPh = %s", serialPassPh);
    // printf("\n");

    for (int j=0; j<SHA256_DIGEST_LENGTH; j++) {
      hashBytesStructPtr->hash_bytes[i*SHA256_DIGEST_LENGTH + j] = (unsigned char)hashAsByteArray[j];
    }
  }

  return hashBytesStructPtr;
}


struct hash_bytes_struct* calcHashBytesLong(long serialStart, long hashCount) {
  struct hash_bytes_struct* hashBytesStructPtr = (struct hash_bytes_struct*) malloc(sizeof(struct hash_bytes_struct));
  int  retVal;
  char serialNumStr[MAX_UNSIGNED_LONG_DIGITS + 2];                                  // 20 digits + '\n' + '\0' = 22
  char serialPassPh[MAX_PASSPHRASE_LENGTH + 1 + MAX_UNSIGNED_LONG_DIGITS + 1 + 1];  // 1023 + 1 + 20 + 1 + 1 = 1046 (the ones are for '\n', '\n', '\0')
  int hashBytesLength = hashCount * SHA256_DIGEST_LENGTH;
  unsigned char hashAsByteArray[SHA256_DIGEST_LENGTH];

  // printf("calcHashBytes: serialStart = %ld\n", serialStart);
  // printf("calcHashBytes: hashCount   = %ld\n", hashCount);
  // printf("\n");

  hashBytesStructPtr->length     = hashCount;
  hashBytesStructPtr->hash_bytes = (unsigned char*) malloc(hashCount * SHA256_DIGEST_LENGTH * sizeof(unsigned char));

  for (long i=0; i<hashCount*SHA256_DIGEST_LENGTH; i++) {
    hashBytesStructPtr->hash_bytes[i] = 0;
  }

  for (long i=0; i<hashCount; i++) {
    // sprintf(serialNumStr, "%20ld\n", i + serialStart);
    sprintf(serialNumStr, "%20ld\n", (i + serialStart)*serialStepLong + serialStartLong);
    sprintf(serialPassPh, "%s%s", passPhrase, serialNumStr);
    calc_sha256_hash_bytes(serialPassPh, hashAsByteArray);

    // printf("calcHashBytes: serialPassPh = %s", serialPassPh);
    // printf("\n");

    for (int j=0; j<SHA256_DIGEST_LENGTH; j++) {
      hashBytesStructPtr->hash_bytes[i*SHA256_DIGEST_LENGTH + j] = (unsigned char)hashAsByteArray[j];
    }
  }

  return hashBytesStructPtr;
}


static int do_getattr( const char *path, struct stat *st ) {
  // printf("do_getattr: path = %s\n", path);

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_getattr: Getting stat info on %s\n", fullPath);

  int res;

  res = lstat(fullPath, st);
  if (res == -1) {
    free(fullPath);
    return -errno;
  }
  else {
    free(fullPath);
    return 0;
  }
}


static int do_readdir( const char *path, void *buffer, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi ) {
  // printf("do_readdir: path = %s\n", path);

  char*   fullPath = NULL;
  DIR*    dr       = NULL;

  struct dirent *de;

  if (strcmp(path, "/") == 0) { // Root directory relative to mount point
    // printf("do_readdir: reading underlying storage directory %s\n", globalOtpfsUserData->source_dir);
    dr = opendir(globalOtpfsUserData->source_dir); // The underlying top-level directory where files are actually stored
  }
  else {
    fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
    sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
    // printf("do_readdir: reading underlying storage directory %s\n", fullPath);
    dr = opendir(fullPath); // The underlying top-level directory where files are actually stored
    free(fullPath);
  }

  if (dr == NULL) {
    // printf("Unable to open the directory!\n");
    return -errno;
  }
  else {
    while ((de = readdir(dr)) != NULL) {
      filler(buffer, de->d_name, NULL, 0);
    }
    closedir(dr);
  }

  return 0;
}


static int do_read(const char *path, char *buffer, size_t size, off_t offset, struct fuse_file_info *fi) {
  // printf("do_read: path = %s, offset = %u, size = %u\n", path, (unsigned long)offset, (unsigned int)size);

  int r;
  int fd;
  int offsetMod32 = ((unsigned long)offset) % SHA256_DIGEST_LENGTH; // mod 32
  struct stat st;

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_read: Getting stat file attributes for fullPath = %s\n", fullPath);

  long fileSizeInBytes = 0;

  if (stat(fullPath, &st) == 0) {
    fileSizeInBytes = (st.st_size);
  }
  else {
    free(fullPath);
    return -errno;
  }

  if (offset + size < fileSizeInBytes) {
    if ((fd = open(fullPath, O_RDONLY)) != -1) {
      r = 0;
      lseek(fd, offset, SEEK_SET);
      if ((r = read(fd, (char *)buffer, size)) == -1) {
        close(fd);
        free(fullPath);
        return -errno;
      }
      close(fd);
      struct hash_bytes_struct* hashBytesStructPtr = NULL;
      if (serialType == SERIAL_TYPE_LONG) {
        hashBytesStructPtr = calcHashBytesLong( (long)(offset/SHA256_DIGEST_LENGTH), (long)(r/SHA256_DIGEST_LENGTH) + 2 ); // dividing by 32
      }
      else {
        hashBytesStructPtr = calcHashBytesInt(   (int)(offset/SHA256_DIGEST_LENGTH),  (int)(r/SHA256_DIGEST_LENGTH) + 2 ); // dividing by 32
      }
      for (int i=0; i<r; i++) {
        buffer[i] ^= hashBytesStructPtr->hash_bytes[i + offsetMod32];  // Decrypt via XOR with one-time-pad bits
      }
      free(hashBytesStructPtr);  // (this also frees hashBytesStructPtr->hash_bytes)
      free(fullPath);
      return r;
    } else {
      free(fullPath);
      return -errno;
    }
  }
  else if (size >= fileSizeInBytes - offset) {
    if ((fd = open(fullPath, O_RDONLY)) != -1) {
      r = 0;
      lseek(fd, offset, SEEK_SET);
      if ((r = read(fd, (char *)buffer, fileSizeInBytes - offset)) == -1) {
        close(fd);
        free(fullPath);
        return -errno;
      }
      close(fd);
      struct hash_bytes_struct* hashBytesStructPtr = NULL;
      if (serialType == SERIAL_TYPE_LONG) {
        hashBytesStructPtr = calcHashBytesLong( (long)(offset/SHA256_DIGEST_LENGTH), (long)(r/SHA256_DIGEST_LENGTH) + 2 ); // dividing by 32
      }
      else {
        hashBytesStructPtr = calcHashBytesInt(   (int)(offset/SHA256_DIGEST_LENGTH),  (int)(r/SHA256_DIGEST_LENGTH) + 2 ); // dividing by 32
      }
      for (int i=0; i<r; i++) {
        buffer[i] ^= hashBytesStructPtr->hash_bytes[i + offsetMod32];  // Decrypt via XOR with one-time-pad bits
      }
      free(hashBytesStructPtr);  // (this also frees hashBytesStructPtr->hash_bytes)
      free(fullPath);
      return r;

    } else {
      free(fullPath);
      return -errno;
    }
  }
  else {
    free(fullPath);
    return 0;
  }
}


static int do_write(const char *path, const char *buffer, size_t size, off_t offset, struct fuse_file_info *fi)
{
  // printf("do_write: path = %s, offset = %u, size = %u\n", path, (unsigned long)offset, (unsigned int)size);

  int fd;
  int r;
  int offsetMod32 = ((unsigned long)offset) % SHA256_DIGEST_LENGTH; // mod 32
  char xorBuf[262144];            // hopefully, this is enough bytes
  for (int i=0; i<262144; i++) {  // under normal/default conditions, the write buffer size will be smaller than this
    xorBuf[i] = 0;
  }

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_write: Opening file for writing: fullPath = %s\n", fullPath);

  if ((fd = open(fullPath, O_WRONLY | O_CREAT )) != -1) {
    r = 0;
    lseek(fd, offset, SEEK_SET);
    struct hash_bytes_struct* hashBytesStructPtr = NULL;
    if (serialType == SERIAL_TYPE_LONG) {
      hashBytesStructPtr = calcHashBytesLong( (long)(offset/SHA256_DIGEST_LENGTH), (long)(size/SHA256_DIGEST_LENGTH) + 2 ); // dividing by 32
    }
    else {
      hashBytesStructPtr = calcHashBytesInt(   (int)(offset/SHA256_DIGEST_LENGTH),  (int)(size/SHA256_DIGEST_LENGTH) + 2 ); // dividing by 32
    }
    for (int i=0; i<size; i++) {
      xorBuf[i] = buffer[i] ^ hashBytesStructPtr->hash_bytes[i + offsetMod32];  // Encrypt via XOR with one-time-pad bits
    }
    free(hashBytesStructPtr);  // (this also frees hashBytesStructPtr->hash_bytes)
    if ((r = write(fd, (char *)xorBuf, size)) == -1) {
      close(fd);
      free(fullPath);
      return -errno;
    }
    else {
      close(fd);
      free(fullPath);
      return r;
    }
  } else {
    free(fullPath);
    return -errno;
  }
}


static int do_flush(const char *path, struct fuse_file_info *fi) {
  int res;
  FILE* fptr = NULL;

  fptr = fdopen(fi->fh, "w");  // try 1

  if (fptr != NULL) {
    res = fflush(fptr);
    return 0;
  }
  else {
    fptr = fdopen(fi->fh, "r");  // try 2

    if (fptr != NULL) {
      res = fflush(fptr);
      return 0;
    }
    else {
      res = errno;
      perror("do_flush: fptr was NULL");
      printf("\n");
      return -res;
    }
  }
}


static int do_truncate(const char *path, off_t offset)
{
  // printf("do_truncate: path = %s, offset = %u\n", path, offset);

  int r;

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_truncate: Opening file for truncating (writing): fullPath = %s\n", fullPath);

  if (r = truncate(fullPath, offset) != -1) {
    free(fullPath);
    return offset;
  }
  else {
    free(fullPath);
    return -errno;
  }
}


// Some data to provide to the "df -h" command
static int do_statfs(const char *path, struct statvfs *buf)
{
  // printf("do_statfs: path = %s\n", path);
  // printf("do_statfs: sizeof statvfs buf = %d\n", (int)sizeof(struct statvfs));

  int res;

  res = statvfs(globalOtpfsUserData->source_dir, buf);
  if (res == -1) {
    return -errno;
  }

  return 0;
}


static int do_create(const char *path, mode_t mode, struct fuse_file_info *fi) {
  // printf("do_create: Creating file with path %s and mode %o (octal)\n", path, mode);

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_create: Opening file for creation (writing): fullPath = %s\n", fullPath);

  int res;

  res = open(fullPath, fi->flags, mode);

  if (res == -1) {
    free(fullPath);
    return -errno;
  }
  else {
    fi->fh = res;
    free(fullPath);
    return 0;
  }
}


static int do_access(const char *path, int mask) {
  // printf("do_access: with path %s and mode %d (%x hex) (%o octal)\n", path, mask, mask, mask);

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_access: fullPath = %s\n", fullPath);

  int res;

  res = access(fullPath, mask);

  if (res == -1) {
    free(fullPath);
    return -errno;
  }
  else {
    free(fullPath);
    return 0;
  }
}


static int do_utimens(const char *path, const struct timespec ts[2]) {
  // printf("do_utimens: path = %s\n", path);

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_utimens: fullPath = %s\n", fullPath);

  int res;

  res = utimensat(0, fullPath, ts, AT_SYMLINK_NOFOLLOW);

  if (res == -1) {
    free(fullPath);
    return -errno;
  }
  else {
    free(fullPath);
    return 0;
  }
}


static int do_open(const char *path, struct fuse_file_info *fi) {
  // printf("do_open: path = %s\n", path);

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_open: fullPath = %s\n", fullPath);

  int res;

  res = open(fullPath, fi->flags);

  if (res == -1) {
    free(fullPath);
    return -errno;
  }
  else {
    fi->fh = res;
    free(fullPath);
    return 0;
  }
}


static int do_mkdir(const char *path, mode_t mode) {
  // printf("do_mkdir: path = %s, mode = %o (octal)\n", path, mode);

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_mkdir: fullPath = %s\n", fullPath);

  int res;

  res = mkdir(fullPath, mode);

  if (res == -1) {
    free(fullPath);
    return -errno;
  }
  else {
    free(fullPath);
    return 0;
  }
}


static int do_chmod(const char *path, mode_t mode) {
  // printf("do_chmod: path = %s, mode = %o (octal)\n", path, mode);

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_chmod: fullPath = %s\n", fullPath);

  int res;

  res = chmod(fullPath, mode);

  if (res == -1) {
    free(fullPath);
    return -errno;
  }
  else {
    free(fullPath);
    return 0;
  }
}


static int do_rename(const char *from, const char *to) {
  // printf("do_rename: from = %s, to = %s\n", from, to);

  char* fullPathFrom = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(from) + 32) * sizeof(char));
  char* fullPathTo   = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(to)   + 32) * sizeof(char));
  sprintf(fullPathFrom, "%s%s", globalOtpfsUserData->source_dir, from);
  sprintf(fullPathTo,   "%s%s", globalOtpfsUserData->source_dir, to);
  // printf("do_rename: fullPathFrom = %s\n", fullPathFrom);
  // printf("do_rename: fullPathTo   = %s\n", fullPathTo);

  int res;

  res = rename(fullPathFrom, fullPathTo);

  if (res == -1) {
    free(fullPathFrom);
    free(fullPathTo);
    return -errno;
  }
  else {
    free(fullPathFrom);
    free(fullPathTo);
    return 0;
  }
}


static int do_unlink(const char *path) {
  // printf("do_unlink: path = %s\n", path);

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_unlink: fullPath = %s\n", fullPath);

  int res;

  res = unlink(fullPath);

  if (res == -1) {
    free(fullPath);
    return -errno;
  }
  else {
    free(fullPath);
    return 0;
  }
}


static int do_rmdir(const char *path) {
  // printf("do_rmdir: path = %s\n", path);

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_rmdir: fullPath = %s\n", fullPath);

  int res;

  res = rmdir(fullPath);

  if (res == -1) {
    free(fullPath);
    return -errno;
  }
  else {
    free(fullPath);
    return 0;
  }
}


static int do_chown(const char *path, uid_t uid, gid_t gid) {
  // printf("do_chown: path = %s, uid = %d, gid = %d\n", path, uid, gid);

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_chown: fullPath = %s\n", fullPath);

  int res;

  res = lchown(fullPath, uid, gid);

  if (res == -1) {
    free(fullPath);
    return -errno;
  }
  else {
    free(fullPath);
    return 0;
  }
}


static int do_symlink(const char *from, const char *to) {
  // printf("do_symlink: from = %s, to = %s\n", from, to);

  char* fullPathTo = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(to) + 32) * sizeof(char));
  sprintf(fullPathTo, "%s%s", globalOtpfsUserData->source_dir, to);
  // printf("do_symlink: fullPathTo = %s\n", fullPathTo);

  int res;

  res = symlink(from, fullPathTo);

  if (res == -1) {
    free(fullPathTo);
    return -errno;
  }
  else {
    free(fullPathTo);
    return 0;
  }
}


static int do_link(const char *from, const char *to) {
  // printf("do_link: from = %s, to = %s\n", from, to);

  char* fullPathFrom = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(from) + 32) * sizeof(char));
  char* fullPathTo   = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(to)   + 32) * sizeof(char));
  sprintf(fullPathFrom, "%s%s", globalOtpfsUserData->source_dir, from);
  sprintf(fullPathTo,   "%s%s", globalOtpfsUserData->source_dir, to);
  // printf("do_link: fullPathFrom = %s\n", fullPathFrom);
  // printf("do_link: fullPathTo   = %s\n", fullPathTo);

  int res;

  res = link(fullPathFrom, fullPathTo);

  if (res == -1) {
    free(fullPathFrom);
    free(fullPathTo);
    return -errno;
  }
  else {
    free(fullPathFrom);
    free(fullPathTo);
    return 0;
  }
}


static int do_readlink(const char *path, char *buf, size_t size) {
  // printf("do_readlink: path = %s\n", path);

  char* fullPath = (char*)malloc((strlen(globalOtpfsUserData->source_dir) + strlen(path) + 32) * sizeof(char));
  sprintf(fullPath, "%s%s", globalOtpfsUserData->source_dir, path);
  // printf("do_readlink: fullPath = %s\n", fullPath);

  int res;

  res = readlink(fullPath, buf, size - 1);

  if (res == -1) {
    free(fullPath);
    return -errno;
  }
  else {
    free(fullPath);
    buf[res] = '\0';
    return 0;
  }
}


static struct fuse_operations operations = {
  .getattr  = do_getattr,
  .readdir  = do_readdir,
  .read     = do_read,
  .write    = do_write,
  .flush    = do_flush,
  .truncate = do_truncate,
  .statfs   = do_statfs,
  .create   = do_create,
  .access   = do_access,
  .open     = do_open,
  .utimens  = do_utimens,
  .mkdir    = do_mkdir,
  .chmod    = do_chmod,
  .rename   = do_rename,
  .unlink   = do_unlink,
  .rmdir    = do_rmdir,
  .chown    = do_chown,
  .symlink  = do_symlink,
  .readlink = do_readlink,
  .link     = do_link,

  // Still DODO - Implement these:
  //
  // .mknod       = do_mknod,
  // .destroy     = do_destroy,
  // .fgetattr    = do_fgetattr,
  // .fsync       = do_fsync,
  // .fsyncdir    = do_fsyncdir,
  // .ftruncate   = do_ftruncate,
  // .init        = do_init,
  // .opendir     = do_opendir,
  // .release     = do_release,
  // .releasedir  = do_releasedir,

  // Extra Attributes to implement:
  //
  // .getxattr    = do_getxattr,
  // .listxattr   = do_listxattr,
  // .removexattr = do_removexattr,
  // .setxattr    = do_setxattr,

  // Probably will NOT implement these:
  //
  // .read_buf    = do_read_buf,
  // .write_buf   = do_write_buf,
};


struct parsed_cmdline_args {
  int     modifiedArgc;
  int     userDataArgc;
  char**  modifiedArgv;
  char**  userDataArgv;
};

struct parsed_cmdline_args* parse_args_for_user_data(int argc, char** argv) {
  int userDataKeyIndex = -1;
  int userDataValIndex = -1;

  for (int i=0; i<argc; i++) {
    if (
         (!strcmp("--userdata",  argv[i])) ||
         (!strcmp("--user_data", argv[i])) ||
         (!strcmp("--user-data", argv[i]))
       ) {
      userDataKeyIndex = i;
      userDataValIndex = i + 1;
      break;
    }
  }

  int modifiedArgc = argc;
  int userDataArgc = 0;
  if (userDataKeyIndex >= 0) {
    userDataArgc = 2;
    modifiedArgc -= 2;
  }

  struct parsed_cmdline_args* parsedCmdlineArgs = (struct parsed_cmdline_args*)malloc(sizeof(struct parsed_cmdline_args));
  char** modifiedArgv = (char**)malloc(modifiedArgc * sizeof(char*));
  char** userDataArgv = (char**)malloc(2 * sizeof(char*));

  int j = 0;
  for (int i=0; i<modifiedArgc; i++) {
    if (i == userDataKeyIndex) {
      j += 2;
    }
    modifiedArgv[i] = argv[j];
    j++;
  }

  if (userDataKeyIndex >= 0) {
    userDataArgv[0] = argv[userDataKeyIndex];
    userDataArgv[1] = argv[userDataValIndex];
  }

  printf("modifiedArgc = %d\n", modifiedArgc);
  for (int i=0; i<modifiedArgc; i++) {
    printf("modifiedArgv[%d] = {{{%s}}}\n", i, modifiedArgv[i]);
  }

  printf("\n");

  printf("userDataArgc = %d\n", userDataArgc);
  for (int i=0; i<userDataArgc; i++) {
    printf("userDataArgv[%d] = {{{%s}}}\n", i, userDataArgv[i]);
  }

  parsedCmdlineArgs->modifiedArgc = modifiedArgc;
  parsedCmdlineArgs->userDataArgc = userDataArgc;
  parsedCmdlineArgs->modifiedArgv = modifiedArgv;
  parsedCmdlineArgs->userDataArgv = userDataArgv;

  return parsedCmdlineArgs;
}

struct otpfs_user_data* parseUserData(int userDataArgc, char** userDataArgv) {
  struct otpfs_user_data* otpfsUserData = NULL;  // this is the return value

  int    userDataKeyValueCount = 0;
  char** userDataKeyValueList  = NULL;

  if (userDataArgc > 1) {
    char* userDataKeyValue = strtok(userDataArgv[1], ",");
    while (userDataKeyValue != NULL) {
      userDataKeyValueCount++;
      if (userDataKeyValueCount > 1) {
        userDataKeyValueList = realloc(userDataKeyValueList, userDataKeyValueCount * sizeof(char*));
      }
      else if (userDataKeyValueCount == 1) {
        userDataKeyValueList  = (char**)malloc(sizeof(char*));
      }
      char* kv = (char*)malloc((USERDATA_KV_MAX_LENGTH + 1) * sizeof(char));
      strncpy(kv, userDataKeyValue, USERDATA_KV_MAX_LENGTH);
      userDataKeyValueList[userDataKeyValueCount  - 1] = kv;
      userDataKeyValue = strtok(NULL, ",");
    }

    otpfsUserData = malloc(sizeof(struct otpfs_user_data));  // gets passed into fuse_main as the 4th argument (void* to user_data)

    // Set default values (see the #define section near the top of this file)
    otpfsUserData->show_passphrase = DEFAULT_SHOW_PASSPHRASE;
    otpfsUserData->serial_type     = DEFAULT_SERIAL_TYPE;
    otpfsUserData->serial_start    = DEFAULT_SERIAL_START;
    otpfsUserData->serial_step     = DEFAULT_SERIAL_STEP;
    otpfsUserData->source_dir      = DEFAULT_SOURCE_DIR;

    for (int i=0; i<userDataKeyValueCount; i++) {
      char* userDataKey = strtok(userDataKeyValueList[i], "=");
      if (userDataKey != NULL) {
        char* userDataVal = strtok(NULL, ",");
        if (userDataVal != NULL) {
          // printf("parseUserData: userDataKey[%d] = %s\n", i, userDataKey);
          // printf("parseUserData: userDataVal[%d] = %s\n", i, userDataVal);
          if (!strcmp("show_passphrase", userDataKey)) {
            otpfsUserData->show_passphrase = (char*)malloc(4 * sizeof(char));
            memset(otpfsUserData->show_passphrase, '\0', 4 * sizeof(char));
            strncpy(otpfsUserData->show_passphrase, userDataVal, 3);
          }
          if (!strcmp("serial_type", userDataKey)) {
            otpfsUserData->serial_type = (char*)malloc(5 * sizeof(char));
            memset(otpfsUserData->serial_type, '\0', 5 * sizeof(char));
            strncpy(otpfsUserData->serial_type, userDataVal, 4);
          }
          if (!strcmp("serial_start", userDataKey)) {
            otpfsUserData->serial_start = (char*)malloc(11 * sizeof(char));
            memset(otpfsUserData->serial_start, '\0', 11 * sizeof(char));
            strncpy(otpfsUserData->serial_start, userDataVal, 10);
          }
          if (!strcmp("serial_step", userDataKey)) {
            otpfsUserData->serial_step = (char*)malloc(11 * sizeof(char));
            memset(otpfsUserData->serial_step, '\0', 11 * sizeof(char));
            strncpy(otpfsUserData->serial_step, userDataVal, 10);
          }
          if (!strcmp("source_dir", userDataKey)) {
            otpfsUserData->source_dir = (char*)malloc(512 * sizeof(char));
            memset(otpfsUserData->source_dir, '\0', 512 * sizeof(char));
            strncpy(otpfsUserData->source_dir, userDataVal, 511);
          }
        }
      }
    }
    printf("\n");

    globalOtpfsUserData = otpfsUserData;  // this is a global variable
  }

  if (!strcmp("int", otpfsUserData->serial_type)) {
    serialType = SERIAL_TYPE_INT;
    if (strcmp("0", otpfsUserData->serial_start)) {
      sscanf(otpfsUserData->serial_start, "%u", &serialStartInt);
    }
    if (strcmp("1", otpfsUserData->serial_step)) {
      sscanf(otpfsUserData->serial_step, "%u", &serialStepInt);
    }
  }
  if (!strcmp("long", otpfsUserData->serial_type)) {
    serialType = SERIAL_TYPE_LONG;
    if (strcmp("0", otpfsUserData->serial_start)) {
      sscanf(otpfsUserData->serial_start, "%lu", &serialStartLong);
    }
    if (strcmp("1", otpfsUserData->serial_step)) {
      sscanf(otpfsUserData->serial_step, "%lu", &serialStepLong);
    }
  }

  return otpfsUserData;
}

int main( int argc, char *argv[] ) {
  struct parsed_cmdline_args* parsedCmdlineArgs = parse_args_for_user_data(argc, argv);

  struct otpfs_user_data* otpfsUserData = NULL;

  if (parsedCmdlineArgs->userDataArgc == 2) {
    otpfsUserData = parseUserData(
      parsedCmdlineArgs->userDataArgc,
      parsedCmdlineArgs->userDataArgv);

    printf("\nType in your passphrase, then press Return:\n\n");
    if (strcmp("yes", otpfsUserData->show_passphrase)) {
      system("stty -echo");
    }
    scanf("%1023[^\n]", passPhrase);  // TODO: remove hard-coded 1023, use MAX_PASSPHRASE_LENGTH to build the format string
    if (strlen(passPhrase) < MAX_PASSPHRASE_LENGTH) {
      passPhrase[strlen(passPhrase) + 1] = 0;
      passPhrase[strlen(passPhrase)] = '\n';
    }
    if (strcmp("yes", otpfsUserData->show_passphrase)) {
      system("stty echo");
    }
    // printf("\n{{{%s}}}\n", passPhrase);
    printf("\nPassphrase accepted.\n\n");

    printf("otpfsUserData->show_passphrase = %s\n", otpfsUserData->show_passphrase);
    printf("otpfsUserData->serial_type     = %s\n", otpfsUserData->serial_type);
    printf("otpfsUserData->serial_start    = %s\n", otpfsUserData->serial_start);
    printf("otpfsUserData->serial_step     = %s\n", otpfsUserData->serial_step);
    printf("otpfsUserData->source_dir      = %s\n", otpfsUserData->source_dir);
    printf("\n");
  }

  return fuse_main(
    parsedCmdlineArgs->modifiedArgc, // argument count
    parsedCmdlineArgs->modifiedArgv, // array of pointers to argument strings (such as '-f', 'mount-point-dirname')
    &operations,                     // fuse_operations struct with pointers to implemented functions
    otpfsUserData                    // usually NULL, but can be a pointer to a "user_data" structure
  );                                 //   (goes into fc->private_data -- struct fuse_context* fc = fuse_get_context())
}
